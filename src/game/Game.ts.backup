import { DGCRapidGame, GameObject, GameEvent, type DGCRapidEngineConfig, Room, RoomManager } from '../engine'
import { GameBoard, Player, Enemy, Item } from './gameobjects'
import { GameRoom, MenuRoom, SpriteTestRoom } from './rooms'
import { Grid } from './Grid'
import { ds_grid_create, ds_grid_get, ds_grid_set, ds_grid_width, ds_grid_height, gml_set_game_instance } from './gml'
import { TurnManager } from './TurnManager'
import { Color } from 'rapid-render'

/**
 * Turn-based movement game that extends the DGCRapidGame class
 * Demonstrates the capabilities of the DGC Engine with GameMaker-style objects and rooms
 */
export class Game extends DGCRapidGame {
  private gameBoard: GameBoard | null = null
  private player: Player | null = null
  private roomManager: RoomManager
  private devUIVisible: boolean = false // Track dev UI visibility state
  private turnManager: TurnManager = new TurnManager()
  private lastClickTarget: { x: number, y: number } | null = null

  constructor(canvas: HTMLCanvasElement) {
    super(canvas)
    
    // Initialize room manager
    this.roomManager = new RoomManager()
  }

  /**
   * Get the engine configuration for this game
   */
  protected getEngineConfig(): DGCRapidEngineConfig {
    return {
      canvas: this.canvas,
      gridWidth: 12,  // Narrower for portrait
      gridHeight: 20, // Taller for portrait
      targetFPS: 60,
      cellSize: 30,
      gridOffset: { x: 50, y: 50 },
      rapidConfig: {
        backgroundColor: Color.fromHex("333333"),
        antialias: true
      }
    }
  }

  /**
   * Setup game-specific logic after engine creation
   */
  protected async setupGame(): Promise<void> {
    // Setup GML game instance reference for compatibility functions
    gml_set_game_instance(this)
    
    // Setup engine integration
    this.setupEngineIntegration()
    
    // Initialize room manager
    this.roomManager.initialize()
    
    // Setup rooms
    this.setupRooms()
    
    // Add development UI for debugging
    if (import.meta.env.DEV) {
      // Start with dev UI hidden - use F12 or Ctrl+D to show
      console.log('ðŸ’¡ Dev UI available! Press F12 or Ctrl+D to toggle visibility')
    }
    
    // Start with the sprite test room
    await this.roomManager.goToRoom('sprite_test')
  }

  /**
   * Setup all game rooms
   */
  private setupRooms(): void {
    // Add room instances to the manager
    this.roomManager.addRoom(new GameRoom(this))
    this.roomManager.addRoom(new MenuRoom(this))
    this.roomManager.addRoom(new SpriteTestRoom(this))
  }

  /**
   * Setup integration between the DGC engine and the game systems
   */
  private setupEngineIntegration(): void {
    // Create a system object to handle room manager updates
    const roomSystemObject = this.createGameObject('room_system', 0, 0)
    roomSystemObject.visible = false // Hidden system object
    
    roomSystemObject.addEventScript(GameEvent.STEP, async (_self) => {
      // Update room manager every frame
      await this.roomManager.step()
    })
    
    roomSystemObject.addEventScript(GameEvent.DRAW, async (_self) => {
      // Handle room drawing
      await this.roomManager.draw()
    })
    
    // Setup event handlers for input using the DGC engine's input system
    this.setupInputHandlers()
    
    console.log('ðŸ”§ DGC Engine integration setup complete')
  }

  /**
   * Setup input handlers for the game
   */
  private setupInputHandlers(): void {
    // Input handling will be done through PIXI event system in rooms
    // or through the DGC engine's input manager
    console.log('ðŸŽ® Input handlers ready')
  }

  // TODO: These methods need to be refactored for the DGC engine
  /*
  /**
   * Handle mouse click for turn-based movement
   * TODO: Re-implement with Rapid.js drawing system
   */
  /*
  private handleMouseClick(eventData: any): void {
    if (!this.gameBoard || !this.player) return
    
    // Prevent new moves while player is already moving
    if (this.player.getVariable('isMoving')) {
      console.log('Player is already moving! Wait for current movement to complete.')
      return
    }
    
    const gridPos = eventData.gridPosition
    if (!gridPos || !this.gameBoard.isValidPosition(gridPos.x, gridPos.y)) return
    
    // Only allow clicks during player's turn
    if (!this.turnManager.isPlayersTurn()) {
      console.log('Not your turn! Wait for enemies to finish moving.')
      return
    }

    const renderer = this.getRenderer()
    if (!renderer) return

    // Check if clicking on the same target
    if (this.lastClickTarget && 
        this.lastClickTarget.x === gridPos.x && 
        this.lastClickTarget.y === gridPos.y) {
      
      // Second click on same target - execute movement
      if (this.gameBoard.isWalkable(gridPos.x, gridPos.y)) {
        this.executePlayerMovement(gridPos)
      } else {
        console.log('Cannot move to that position - blocked!')
        this.clearTargetAndPath()
      }
    } else {
      // First click or different target - show path
      if (this.gameBoard.isWalkable(gridPos.x, gridPos.y)) {
        this.showMovementPath(gridPos)
      } else {
        console.log('Cannot target that position - blocked!')
      }
    }
  }
  */

  /**
   * Show the movement path to the target
   */
  private showMovementPath(target: { x: number, y: number }): void {
    if (!this.gameBoard || !this.player) return

    const playerPos = { x: Math.floor(this.player.x), y: Math.floor(this.player.y) }
    const path = this.gameBoard.calculatePath(playerPos, target)
    
    this.lastClickTarget = target
    
    const renderer = this.getRenderer()
    if (renderer) {
      renderer.drawPath(path)
      renderer.drawTarget(target)
    }
    
    console.log(`Click again on (${target.x}, ${target.y}) to move there`)
  }

  /**
   * Execute the player movement and start enemy turn
   */
  private executePlayerMovement(target: { x: number, y: number }): void {
    if (!this.player || !this.gameBoard) return

    // Calculate the full path from current position to target
    const playerPos = { x: Math.floor(this.player.x), y: Math.floor(this.player.y) }
    const path = this.gameBoard.calculatePath(playerPos, target)
    
    // Clear path and target visuals immediately
    this.clearTargetAndPath()
    
    // Execute player's turn
    this.turnManager.executePlayerMove()
    
    // Animate player movement along the path with enemy steps
    this.player.animateAlongPath(
      path,
      (stepIndex: number) => {
        // For each player step, execute one enemy step
        console.log(`Player step ${stepIndex + 1} complete, executing enemy steps...`)
        this.executeEnemyStep()
      },
      () => {
        console.log(`Player movement complete: reached (${target.x}, ${target.y})`)
        
        // Complete the turn sequence after all movement is done
        setTimeout(() => {
          this.turnManager.completeEnemyTurn()
          this.updateGameRenderer()
        }, 200) // Small delay for visual feedback
      }
    )
  }

  /**
   * Execute one step of movement for all enemies
   */
  public executeEnemyStep(): void {
    if (!this.gameBoard || !this.player) return

    const engine = this.getEngine()
    if (!engine) return

    // Get all enemy objects
    const enemies: Enemy[] = []
    const allObjects = engine.getObjectManager().getAllObjects()
    
    for (const obj of allObjects) {
      if (obj.objectType === 'Enemy' && obj instanceof Enemy) {
        enemies.push(obj)
      }
    }

    // Update enemy targets (check for player in range)
    const playerPos = { x: Math.floor(this.player.x), y: Math.floor(this.player.y) }
    
    for (const enemy of enemies) {
      const enemyPos = { x: Math.floor(enemy.x), y: Math.floor(enemy.y) }
      const distance = Math.sqrt(
        Math.pow(playerPos.x - enemyPos.x, 2) + 
        Math.pow(playerPos.y - enemyPos.y, 2)
      )
      
      const detectionRange = enemy.getVariable('detectionRange') || 5
      
      if (distance <= detectionRange) {
        enemy.setTarget(playerPos.x, playerPos.y)
      } else {
        enemy.clearTarget()
      }
    }

    // Execute one step of movement for each enemy
    let enemiesMoved = 0
    for (const enemy of enemies) {
      if (enemy.executeTurn(this.gameBoard)) {
        enemiesMoved++
      }
    }

    if (enemiesMoved > 0) {
      console.log(`${enemiesMoved} enemies moved one step`)
    }
    
    // Update renderer to show enemy movements
    this.updateGameRenderer()
  }

  /**
   * Clear target and path visuals
   */
  private clearTargetAndPath(): void {
    this.lastClickTarget = null
    const renderer = this.getRenderer()
    if (renderer) {
      renderer.clearPath()
      renderer.clearTarget()
    }
  }

  /**
   * Setup keyboard event handlers
   */
  private setupKeyboardHandlers(): void {
    if (!import.meta.env.DEV) return
    
    document.addEventListener('keydown', (event) => {
      // Toggle dev UI with F12 key - TEMPORARILY DISABLED FOR DEBUGGING
      // if (event.key === 'F12') {
      //   event.preventDefault()
      //   this.toggleDevUI()
      // }
      
      // Alternative: Toggle dev UI with Ctrl+D
      if (event.ctrlKey && event.key === 'd') {
        event.preventDefault()
        this.toggleDevUI()
      }
    })
  }

  /**
   * Toggle development UI visibility
   */
  private toggleDevUI(): void {
    if (!import.meta.env.DEV) return
    
    const devUI = document.getElementById('devUI')
    if (!devUI) {
      // Dev UI doesn't exist, create it
      this.addDevUI()
      this.devUIVisible = true
      console.log('Dev UI shown (F12 or Ctrl+D to toggle)')
      return
    }
    
    this.devUIVisible = !this.devUIVisible
    this.setDevUIVisible(this.devUIVisible)
    console.log(`Dev UI ${this.devUIVisible ? 'shown' : 'hidden'} (F12 or Ctrl+D to toggle)`)
  }

  /**
   * Get current dev UI visibility state
   */
  public isDevUIVisible(): boolean {
    return this.devUIVisible
  }

  /**
   * Create an enemy at a specific position
   */
  public createEnemy(x: number, y: number): GameObject {
    const enemy = this.createGameObject('Enemy', x, y)
    enemy.solid = true
    enemy.visible = true
    enemy.setVariable('health', 50)
    
    // Add simple AI behavior
    enemy.addEventScript(GameEvent.STEP, (self) => {
      // Simple random movement
      if (Math.random() < 0.01) { // 1% chance per frame
        const direction = Math.floor(Math.random() * 4)
        const currentPos = self.getPosition()
        let newX = currentPos.x
        let newY = currentPos.y
        
        switch (direction) {
          case 0: newY--; break // Up
          case 1: newY++; break // Down
          case 2: newX--; break // Left
          case 3: newX++; break // Right
        }
        
        // Check bounds and walkability
        if (this.gameBoard && this.gameBoard.isWalkable(newX, newY)) {
          self.setPosition(newX, newY)
        }
      }
    })
    
    return enemy
  }

  /**
   * Create an item at a specific position
   */
  public createItem(x: number, y: number, itemType: string = 'coin'): GameObject {
    const item = this.createGameObject('Item', x, y)
    item.solid = false
    item.visible = true
    item.setVariable('itemType', itemType)
    item.setVariable('value', 10)
    
    return item
  }

  /**
   * Get the game board
   */
  public getGameBoard(): GameBoard | null {
    return this.gameBoard
  }

  /**
   * Set the game board (for room-based creation)
   */
  public setGameBoard(gameBoard: GameBoard | null): void {
    this.gameBoard = gameBoard
  }

  /**
   * Set the player (for room-based creation)
   */
  public setPlayer(player: Player | null): void {
    this.player = player
    // Set game instance reference for turn-based keyboard movement
    if (player) {
      player.setGameInstance(this)
    }
  }

  /**
   * Get the player
   */
  public getPlayer(): Player | null {
    return this.player
  }

  /**
   * Add object to the game engine (exposed for room access)
   */
  public addGameObject(gameObject: GameObject): void {
    this.addObject(gameObject)
  }

  /**
   * Get the turn manager
   */
  public getTurnManager(): TurnManager {
    return this.turnManager
  }

  /**
   * Reset the turn manager (called when starting a new game)
   */
  public resetTurnManager(): void {
    this.turnManager.reset()
    this.lastClickTarget = null
  }

  /**
   * Update the game renderer - exposed for room access
   */
  public updateGameRenderer(): void {
    if (!this.isGameInitialized) return
    
    const renderer = this.getRenderer()
    if (!renderer || !this.gameBoard) return
    
    // Clear and redraw the grid (game-specific rendering)
    renderer.clear()
    renderer.drawGrid(this.gameBoard)
    
    // The engine will handle drawing all game objects automatically
    // through its render() method in the game loop
  }

  /**
   * Get the game canvas element
   */
  public getCanvas(): HTMLCanvasElement {
    return this.canvas
  }

  /**
   * Get the room manager for advanced room operations
   */
  public getRoomManager(): RoomManager {
    return this.roomManager
  }

  /**
   * Switch to a different room
   */
  public async goToRoom(roomName: string): Promise<boolean> {
    return await this.roomManager.goToRoom(roomName)
  }

  /**
   * Get the current active room
   */
  public getCurrentRoom(): Room | undefined {
    return this.roomManager.getCurrentRoom()
  }

  /**
   * Setup initial game content and objects
   */
  public setupInitialContent(): void {
    const engine = this.getEngine()
    
    // ===== GRID SYSTEM DEMONSTRATION =====
    console.log('ðŸŽ® Grid system supports both coding approaches:')
    
    // Modern TypeScript approach
    console.log('--- Modern TypeScript Approach ---')
    const modernGrid = new Grid<number>(5, 5, 0)
    modernGrid.set(2, 2, 999)
    console.log(`Modern grid value at (2,2): ${modernGrid.get(2, 2)}`)
    console.log(`Modern grid dimensions: ${modernGrid.getWidth()} x ${modernGrid.getHeight()}`)
    
    // GameMaker style approach
    console.log('--- GameMaker (GML) Style Approach ---')
    var gmlGrid = ds_grid_create(5, 5)
    ds_grid_set(gmlGrid, 2, 2, 999)
    console.log(`GML grid value at (2,2): ${ds_grid_get(gmlGrid, 2, 2)}`)
    console.log(`GML grid dimensions: ${ds_grid_width(gmlGrid)} x ${ds_grid_height(gmlGrid)}`)
    
    console.log('âœ… Both approaches work! Developers can choose their preferred style.')
    
    // Create initial enemies
    const enemy1 = new Enemy(10, 5, 'guard')
    const enemy2 = new Enemy(15, 8, 'scout')
    const enemy3 = new Enemy(5, 10, 'guard')
    
    // Register enemies with the engine
    engine.getObjectManager().addExistingObject(enemy1)
    engine.getObjectManager().addExistingObject(enemy2)
    engine.getObjectManager().addExistingObject(enemy3)
    
    // Create initial collectible items
    const coin1 = Item.createCoin(3, 3, 15)
    const gem1 = Item.createGem(7, 7, 50)
    const coin2 = Item.createCoin(12, 4, 10)
    const healthPotion = Item.createHealthPotion(18, 12, 30)
    const key = Item.createKey(1, 1)
    
    // Register items with the engine
    engine.getObjectManager().addExistingObject(coin1)
    engine.getObjectManager().addExistingObject(gem1)
    engine.getObjectManager().addExistingObject(coin2)
    engine.getObjectManager().addExistingObject(healthPotion)
    engine.getObjectManager().addExistingObject(key)
    
    console.log('Initial game content loaded!')
  }

  /**
   * Add development UI for debugging and testing (development only)
   */
  public addDevUI(): void {
    const engine = this.getEngine()
    
    // Create UI container
    const uiContainer = document.createElement('div')
    uiContainer.id = 'devUI'
    uiContainer.style.cssText = `
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 14px;
      z-index: 1000;
    `
    
    // Add game info and controls
    uiContainer.innerHTML = `
      <h3>DGC Engine Game</h3>
      <p><strong>Controls:</strong></p>
      <ul>
        <li>Click to move player</li>
        <li>WASD/Arrow keys for direct movement</li>
        <li>Space to cancel movement</li>
      </ul>
      <p><strong>Engine Features:</strong></p>
      <ul>
        <li>Event-driven object system</li>
        <li>Collision detection</li>
        <li>Pathfinding and movement</li>
        <li>Custom variables and timers</li>
      </ul>
      <div id="gameStats">
        <p>Objects: <span id="objectCount">0</span></p>
        <p>FPS: <span id="fpsCounter">0</span></p>
      </div>
      <button id="createEnemyBtn">Create Enemy</button>
      <button id="createItemBtn">Create Item</button>
      <button id="restartBtn">Restart Game</button>
    `
    
    document.body.appendChild(uiContainer)
    
    // Update stats periodically
    setInterval(() => {
      const objectCount = engine.getObjectManager().getObjectCount()
      const fps = Math.round(engine.getFPS())
      
      const objectCountEl = document.getElementById('objectCount')
      const fpsCounterEl = document.getElementById('fpsCounter')
      
      if (objectCountEl) objectCountEl.textContent = objectCount.toString()
      if (fpsCounterEl) fpsCounterEl.textContent = fps.toString()
    }, 100)
    
    // Add button event listeners
    document.getElementById('createEnemyBtn')?.addEventListener('click', () => {
      const x = Math.floor(Math.random() * 20)
      const y = Math.floor(Math.random() * 15)
      const enemy = new Enemy(x, y, 'random')
      engine.getObjectManager().addExistingObject(enemy)
      console.log('Enemy created at', { x, y })
    })
    
    document.getElementById('createItemBtn')?.addEventListener('click', () => {
      const x = Math.floor(Math.random() * 20)
      const y = Math.floor(Math.random() * 15)
      const itemTypes = ['coin', 'gem', 'health_potion', 'key']
      const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)]
      
      let item: Item
      switch (itemType) {
        case 'coin': item = Item.createCoin(x, y); break
        case 'gem': item = Item.createGem(x, y); break
        case 'health_potion': item = Item.createHealthPotion(x, y); break
        case 'key': item = Item.createKey(x, y); break
        default: item = Item.createCoin(x, y)
      }
      
      engine.getObjectManager().addExistingObject(item)
      console.log('Item created at', { x, y })
    })
    
    document.getElementById('restartBtn')?.addEventListener('click', async () => {
      // Simple restart - just reset the game state
      this.setupInitialContent()
      console.log('Game restarted!')
    })
  }

  /**
   * Show/hide development UI based on room
   */
  public setDevUIVisible(visible: boolean): void {
    if (!import.meta.env.DEV) return
    
    const devUI = document.getElementById('devUI')
    if (devUI) {
      devUI.style.display = visible ? 'block' : 'none'
    }
  }

  /**
   * Remove development UI completely
   */
  public removeDevUI(): void {
    if (!import.meta.env.DEV) return
    
    const devUI = document.getElementById('devUI')
    if (devUI && devUI.parentNode) {
      devUI.parentNode.removeChild(devUI)
    }
  }

  /**
   * Get the underlying DGC engine instance
   */
  public getEngine() {
    return this.engine
  }
}
